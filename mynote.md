## notes

### life of frame

- 输入事件：优先级最高，以让用户得到最快反馈
- timers：定时器到时间的回调
- GUI 渲染和 script 引擎 同一个线程，互斥，是性能优化的基础

### requestIdleCallback

- 不要在空闲时间 idle 操作 dom，引起重新渲染
- 这个调度方式叫合作式调度,需要浏览器相信用户写的代码
  但是如果用户写代码时,或者执行时间超过给的剩余时间,浏览器没有办法

### 为啥 fiber 用链表，不用 generator?

React 开发⼈员在 git issue ⾥回答过这个问题. 总结起来主要的就是两点:

- 要使⽤ generator 的话, 需要将涉及的所有代码都包装成 `generator *` 的形式, ⾮常麻烦
- generator 内部是有状态的, 很难在恢复执⾏的时候获取之前的状态.

```js
// ⽐如这段代码, 如果想在多个时间分⽚内执⾏, ⽽当我们在之前的时间⽚内已经执⾏完了doExpensiveWorkA 和 doExpensiveWorkB, 还没执⾏doExpensiveWorkC, 但是此时b被更新了. 那么在新的时间分⽚⾥, 我们只能沿⽤之前获取到的x和y的结果, 来执⾏doExpensiveWorkC. ⽽我们⽆法获取到更新后的b的值, 再来继续做doExpensiveWorkC的计算.
function* doWork(a, b, c) {
  var x = doExpensiveWorkA(a);
  yield;
  var y = x + doExpensiveWorkB(b);
  yield;
  var z = y + doExpensiveWorkC(c);
  return z;
}
```

其实 react 团队试过，但放弃了，不方便.
性能较差，而且低版本浏览器的 polyfile 代码比较冗余，所以 react 团队放弃了.
链表是数据结构，而 generator 是异步解决方案.

### timeout 超时后就⼀定要被执⾏吗?

在 react ⾥不是的, react 预订了 5 个优先级, 低优先级的可以慢慢等待, ⾼优先级的任务应该率先被执⾏.

- Immediate(-1) - 这个优先级的任务会同步执⾏, 或者要⻢上执⾏且不能中断
- UserBlocking(250ms) 这些任务⼀般是⽤户交互的结果, 需要即时得到反馈
- Normal (5s) 应对哪些不需要⽴即感受到的任务，例如⽹络请求
- Low (10s) 这些任务可以放后，但是最终应该得到执⾏. 例如分析通知
- Idle (没有超时时间) ⼀些没有必要做的任务 (e.g. ⽐如隐藏的内容), 可能会被饿死

## questions

1. 浏览器刷新频率怎么和屏幕的刷新频率同步的？
   vSync 标记符，显卡会在每一帧开始的时候给浏览器发送一个 vSynch 标识符.
   帧率是动态调整的，说 16.66ms 只是方便学习理解，其实是看浏览器调度的.
2. 显示器越强，刷新频率越高，一帧的时间越短.
3. 粒度越小越好吗？
   不是，要合适.
4. fiber 解决了什么问题？
   解决了执行栈不能中断的问题，可以干一回停一会.
   核⼼⽬的是为了使 React 渲染过程可以被中断，将控制权交回浏览器，让位给⾼优先级的任务，浏览器空闲后再恢复渲染。这样⾼性能要求的⼀些 dom 计算在设备上就不会显得很卡顿, ⽽是会⼀帧⼀帧的有规律的执⾏, 看起来就⼗分流畅.
5. 时间复杂度上,链表和栈有区别吗?
   时间复杂度上差不多 O(n).
   但是栈比较消耗性能，而且不能中断.
   fber 是单链表，因为链表可以很方便的中断和恢复.
6.
7. react-hook、updatequeue 都是用了链表
   fiber 是把整个任务分成很多个小任务,每次执行一个任务，执行完成后会看看有没剩余时间,如果有继续下一个任务,如果没有放弃执行,交给浏览器进行调度
   任务划分的力度和依据，一个虛拟 D0M 节点 算一个链表节点，是一个 fiber 工作单元
8. 深度优先,举似二叉树前序遍历。
9. vue & react 优化思路不一样

- vue 把每个更新任务分割的足够小，watcher 组件级更新，更新范围很小
  vue3 现在采取的是模板标记更新能很快速的定位到更新的地方进行更新，所以不需要用 fiber，因为已经足够快了
- react 任务还是很大，但是分割成多个小任务，可以中断和恢复，不阻塞主进程执行高优先级任务
- react 不管在哪里调 setstate 都是从根节点开始比较更新的

其实就是二叉树先序遍历 后序
按自身完成状态的顺序组成 effetlist

## fiber

react15
react16 fiber

## vue 号称的依赖收集细粒度染和 fber 前能 有一拼不

- 每个虚拟 DOM 节点 是一个链表节点，也是一个工作单元
- 虚拟 DOM 节点会转成 fiber
- render 阶段的结果是 effect list 副作用链表
- 相当于用链表实现了一个类似于可中断的递归的功能
- 安装函数的思维想, return 更合适一点
