## notes

### life of frame

- 输入事件：优先级最高，以让用户得到最快反馈
- timers：定时器到时间的回调
- GUI 渲染和 script 引擎 同一个线程，互斥，是性能优化的基础

### requestIdleCallback

- 不要在空闲时间 idle 操作 dom，引起重新渲染
- 这个调度方式叫合作式调度,需要浏览器相信用户写的代码
  但是如果用户写代码时,或者执行时间超过给的剩余时间,浏览器没有办法

## questions

1. 浏览器刷新频率怎么和屏幕的刷新频率同步的？
   vSync 标记符，显卡会在每一帧开始的时候给浏览器发送一个 vSynch 标识符.
   帧率是动态调整的，说 16.66ms 只是方便学习理解，其实是看浏览器调度的.
2. 显示器越强，刷新频率越高，一帧的时间越短.
3. 粒度越小越好吗？
   不是，要合适.
4. 时间复杂度上,链表和栈有区别吗?
   时间复杂度上差不多 O(n).
   但是栈比较消耗性能，而且不能中断.
   fber 是单链表，因为链表可以很方便的中断和恢复.
5. 为啥 fiber 用链表不用 generator?
   其实 react 团队试过，但放弃了，不方便.
   性能较差，而且低版本浏览器的 polyfile 代码页比较冗余，所以 react 团队放弃了.
   链表是数据结构，而 generator 是异步解决方案.
6. react-hook、updatequeue 都是用了链表
   fiber 是把整个任务分成很多个小任务,每次执行一个任务，执行完成后会看看有没剩余时间,如果有继续下一个任务,如果没有放弃执行,交给浏览器进行调度
   任务划分的力度和依据，一个虛拟 D0M 节点 算一个链表节点，是一个 fiber 工作单元
7. 深度优先,举似二叉树前序遍历。
